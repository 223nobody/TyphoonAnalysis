# 台风预测功能设计思路与实施方案

## 版本历史

- **V1.0** (2026-02-14): 初始版本，总结前期问题
- **V2.0** (2026-02-14): 修复版本，解决特征维度和预处理一致性问题
- **V3.0** (2026-02-14): 系统优化版本，完善GPU支持、性能优化和文档

---

## 一、项目概述

### 1.1 系统架构

本项目是一个基于PyTorch深度学习框架的台风路径与强度预测系统，完全使用项目内的CSV历史数据作为训练数据源，支持GPU加速训练。

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (API)                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐               │
│  │ 路径预测API  │ │ 强度预测API  │ │ 高级预测API  │               │
│  └─────────────┘ └─────────────┘ └─────────────┘               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      推理层 (Predictor)                          │
│  ┌─────────────────┐    ┌─────────────────┐                    │
│  │  TyphoonPredictor │    │ AdvancedPredictor │                    │
│  │  (标准预测)       │    │ (滚动/任意起点)    │                    │
│  └─────────────────┘    └─────────────────┘                    │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      模型层 (Model)                              │

- 统一使用 `FEATURE_COLUMNS` 常量定义14维特征顺序
- `prepare_prediction_input` 方法现在使用 `create_sequences` 方法，确保与训练一致

#### 问题3：特征顺序不一致（已修复）

**现象**：模型输出与输入不匹配
**原因**：

- 训练时的特征顺序：[lat, lon, pressure, wind, moving_speed, hour, month, vel_lat, vel_lon, acc_lat, acc_lon, month_sin, month_cos, placeholder]
- 预测时的特征顺序不同
- 导致模型学习到错误的映射关系

**修复方案**：

- 定义全局常量 `FEATURE_COLUMNS`，所有模块共用同一特征顺序
- 训练和预测都使用 `create_sequences` 方法构建序列

#### 问题4：预处理逻辑不一致（已修复）

**现象**：训练数据和测试数据的预处理方式不同
**原因**：

- 训练时使用 `create_sequences` 方法
- 预测时手动构建特征（`prepare_prediction_input` 中手动选择列）
- 速度和加速度的计算方式不同

**修复方案**：

- `prepare_prediction_input` 方法现在调用 `create_sequences` 方法
- 如果数据不足无法创建序列，则使用相同的特征列顺序手动构建
- 确保所有预处理步骤（特征提取、归一化、序列构建）完全一致

#### 问题5：模型过拟合

**现象**：训练时MAE很低（0.008），但测试时偏差很大（6.37°）
**原因**：

- 训练数据分布单一（主要来自西北太平洋）
- 测试数据是人工生成的简单线性轨迹
- 模型学习了训练数据的统计模式而非物理规律

**教训**：需要更多样化的训练数据，或引入物理约束损失。

### 1.2 设计原则总结

1. **一致性原则**：训练、验证、预测三个阶段的数据处理必须完全一致
2. **可追溯原则**：所有归一化参数、特征顺序必须文档化并版本控制
3. **验证原则**：每个阶段都要有对应的验证机制
4. **模块化原则**：数据预处理、模型训练、预测推理应该解耦

---

## 二、新方案整体设计（V2.0 修复版）

### 2.1 系统架构

```
数据层 → 预处理层 → 模型层 → 推理层 → 应用层
  ↓         ↓         ↓         ↓         ↓
CSV文件  特征工程  Transformer  反归一化  API接口
         归一化    + LSTM      置信度    可视化
         序列构建   混合模型    计算
```

### 2.2 核心组件

#### 2.2.1 数据预处理模块 (DataPreprocessor)

**职责**：

- 数据清洗（去除异常值、重复值）
- 特征工程（速度、加速度、时序编码）
- 归一化/标准化
- 序列构建

**关键设计**：

```python
# 全局特征列定义 - 所有模块共用
FEATURE_COLUMNS = [
    'latitude',           # 0: 纬度 [-90, 90]
    'longitude',          # 1: 经度 [-180, 180]
    'center_pressure',    # 2: 中心气压
    'max_wind_speed',     # 3: 最大风速
    'moving_speed',       # 4: 移动速度
    'hour',               # 5: 小时 [0-23]
    'month',              # 6: 月份 [1-12]
    'velocity_lat',       # 7: 纬度速度
    'velocity_lon',       # 8: 经度速度
    'acceleration_lat',   # 9: 纬度加速度
    'acceleration_lon',   # 10: 经度加速度
    'month_sin',          # 11: 月份正弦编码
    'month_cos',          # 12: 月份余弦编码
    'placeholder'         # 13: 占位符
]

class DataPreprocessor:
    def __init__(self, sequence_length=12, prediction_steps=8):
        self.sequence_length = sequence_length
        self.prediction_steps = prediction_steps
        self.norm_params = NormalizationParams()  # 固定参数

    def extract_features(self, paths) -> pd.DataFrame:
        """提取基础特征"""
        # 1. 基础数据: lat, lon, pressure, wind, moving_speed
        # 2. 时间特征: hour, month, month_sin, month_cos
        # 3. 运动特征: velocity_lat, velocity_lon, acceleration_lat, acceleration_lon
        pass

    def normalize(self, features_df) -> pd.DataFrame:
        """归一化 - 使用固定参数"""
        # lat/lon: Min-Max 归一化到 [0, 1]
        # pressure/wind/moving_speed/velocity/acceleration: Z-Score 标准化
        # hour/month: 归一化到 [0, 1]
        pass

    def create_sequences(self, normalized_df) -> Tuple[np.ndarray, np.ndarray]:
        """构建序列 - 严格固定特征顺序"""
        # 使用 FEATURE_COLUMNS 定义的顺序
        pass

    def prepare_prediction_input(self, paths) -> np.ndarray:
        """准备预测输入 - 使用与训练相同的流程"""
        # 1. 调用 extract_features
        # 2. 调用 normalize
        # 3. 调用 create_sequences
        # 4. 返回最后一个序列或手动构建的序列
        pass

    def denormalize(self, normalized_data) -> np.ndarray:
        """反归一化 - 与normalize对应"""
        pass
```

**特征字段说明**：
| 序号 | 字段名 | 类型 | 说明 | 归一化方式 |
|------|--------|------|------|-----------|
| 0 | latitude | 连续 | 纬度 | Min-Max [0,1] |
| 1 | longitude | 连续 | 经度 | Min-Max [0,1] |
| 2 | center_pressure | 连续 | 中心气压 | Z-Score |
| 3 | max_wind_speed | 连续 | 最大风速 | Z-Score |
| 4 | moving_speed | 连续 | 移动速度 | Z-Score |
| 5 | hour | 离散 | 小时(0-23) | /23 |
| 6 | month | 离散 | 月份(1-12) | /11 |
| 7 | velocity_lat | 连续 | 纬度速度 | Z-Score |
| 8 | velocity_lon | 连续 | 经度速度 | Z-Score |
| 9 | acceleration_lat | 连续 | 纬度加速度 | Z-Score |
| 10 | acceleration_lon | 连续 | 经度加速度 | Z-Score |
| 11 | month_sin | 连续 | 月份正弦编码 | [-1,1] |
| 12 | month_cos | 连续 | 月份余弦编码 | [-1,1] |
| 13 | placeholder | 占位 | 保留字段 | 0 |

#### 2.2.2 归一化参数（固定）

```python
@dataclass
class NormalizationParams:
    """归一化参数 - 必须与训练时完全一致"""
    # 位置特征 Min-Max 归一化参数
    lat_min: float = -90.0
    lat_max: float = 90.0
    lon_min: float = -180.0
    lon_max: float = 180.0

    # 强度特征 Z-Score 标准化参数
    pressure_mean: float = 1000.0
    pressure_std: float = 50.0
    wind_mean: float = 20.0
    wind_std: float = 15.0

    # 移动速度 Z-Score 标准化参数
    moving_speed_mean: float = 15.0
    moving_speed_std: float = 10.0

    # 速度特征 Z-Score 标准化参数
    velocity_mean: float = 0.0
    velocity_std: float = 2.0

    # 加速度特征 Z-Score 标准化参数
    acceleration_mean: float = 0.0
    acceleration_std: float = 0.5
```

#### 2.2.3 模型架构 (TransformerLSTM)

**架构设计**：

```
输入 [batch, seq_len, 14]
    ↓
LSTM编码器 [batch, seq_len, hidden]
    ↓
Transformer编码器 [batch, seq_len, hidden]
    ↓
全局平均池化 [batch, hidden]
    ↓
预测头（8个时间步） [batch, 8, 4]
    ↓
输出: 均值 + 方差 + 置信度
```

**关键参数**：

- input_size: 14
- hidden_size: 256
- num_lstm_layers: 2
- num_transformer_layers: 2
- num_heads: 8
- output_size: 4 (lat, lon, pressure, wind)
- prediction_steps: 8

#### 2.2.4 损失函数设计

**复合损失函数**：

```python
Loss = w1 * NLL(预测, 目标) +
       w2 * MSE(路径) +
       w3 * MSE(强度) +
       w4 * 物理约束损失 +
       w5 * 时序一致性损失 +
       w6 * 置信度校准损失
```

**物理约束损失**：

- 速度合理性：相邻预测点的速度不应突变（6小时最大移动5度，归一化后约0.028）
- 方向合理性：台风移动方向应符合物理规律
- 时序一致性：惩罚剧烈变化

---

## 三、关键实现细节

### 3.1 特征计算逻辑

**速度计算**：

```python
velocity = np.diff(coords, axis=0) / time_interval
# 第一个点的速度设为与第二个点相同
velocity[0] = velocity[1] if len(velocity) > 1 else 0
```

**加速度计算**：

```python
acceleration = np.diff(velocity, axis=0) / time_interval
# 第一个点的加速度设为与第二个点相同
acceleration[0] = acceleration[1] if len(acceleration) > 1 else 0
```

**时序编码**：

```python
month_sin = np.sin(2 * np.pi * month / 12.0)
month_cos = np.cos(2 * np.pi * month / 12.0)
```

### 3.2 预测流程

```python
def predict(historical_paths):
    # 1. 特征提取
    features = preprocessor.extract_features(historical_paths)

    # 2. 归一化
    normalized = preprocessor.normalize(features)

    # 3. 序列构建（使用create_sequences，与训练一致）
    inputs, _ = preprocessor.create_sequences(normalized)
    # 或使用 prepare_prediction_input 直接获取输入

    # 4. 模型推理
    pred_mean, pred_std, confidence = model(input_tensor)

    # 5. 反归一化
    denorm_pred = preprocessor.denormalize(pred_mean)

    # 6. 构建预测结果
    return PredictionResult(...)
```

---

## 四、文件清单

### 4.1 核心文件

| 文件路径                                       | 说明         | 状态      |
| ---------------------------------------------- | ------------ | --------- |
| `app/services/prediction/data/preprocessor.py` | 数据预处理器 | ✅ 已修复 |
| `app/services/prediction/predictor.py`         | 预测器       | ✅ 已修复 |
| `app/services/prediction/data/dataset.py`      | 数据集定义   | ✅ 已验证 |
| `training/train_model_v3.py`                   | 训练脚本V3   | ✅ 已创建 |

### 4.2 修复内容总结

1. **preprocessor.py**:
   - 添加 `FEATURE_COLUMNS` 全局常量定义14维特征顺序
   - 修复 `normalize` 方法，添加所有特征的归一化
   - 修复 `prepare_prediction_input` 方法，使用 `create_sequences`
   - 更新 `NormalizationParams`，添加所有需要的参数

2. **predictor.py**:
   - 简化 `_preprocess` 方法，直接调用 `prepare_prediction_input`
   - 添加更多调试日志
   - 移除旧的兼容性代码

3. **train_model_v3.py**:
   - 使用修复后的预处理逻辑
   - 添加特征列表和归一化参数到模型保存
   - 改进损失函数，添加置信度校准
   - 添加详细的训练历史记录

---

## 五、验证检查清单

### 5.1 代码验证

- [x] 归一化参数一致性检查
- [x] 特征维度检查（14维）
- [x] 特征顺序检查
- [x] 训练/预测预处理一致性检查
- [x] 模型输入输出维度检查
- [x] 反归一化精度检查

### 5.2 训练验证

- [ ] 训练过程损失下降
- [ ] 验证集MAE < 0.1（约10度）
- [ ] 置信度合理（0.5-0.95）
- [ ] 无梯度爆炸/消失

### 5.3 预测验证

- [ ] 坐标合理性检查（lat: 0-45, lon: 100-180）
- [ ] 预测偏差 < 5度
- [ ] 置信度与误差匹配
- [ ] 降级策略正常工作

---

## 六、后续优化建议

### 6.1 数据层面

1. **数据增强**：对训练数据进行随机扰动，增强泛化能力
2. **数据平衡**：确保不同年份、不同强度的台风数据均衡
3. **外部数据**：引入气象再分析数据（ERA5）作为额外特征

### 6.2 模型层面

1. **注意力机制**：可视化Transformer的注意力权重，理解模型关注点
2. **集成学习**：训练多个模型，使用集成方法提高稳定性
3. **在线学习**：支持模型增量更新，适应新的台风模式

### 6.3 评估层面

1. **多指标评估**：除了MAE，增加RMSE、MAPE、方向误差等指标
2. **分位数预测**：输出预测区间，而非点估计
3. **长期预测**：评估48小时、72小时、120小时预测性能

---

## 七、附录

### 7.1 关键配置参数

```yaml
# 数据参数
sequence_length: 12
prediction_steps: 8
time_interval: 6 # 小时

# 模型参数
input_size: 14
hidden_size: 256
num_lstm_layers: 2
num_transformer_layers: 2
num_heads: 8
dropout: 0.2

# 训练参数
batch_size: 64
learning_rate: 0.001
num_epochs: 100
patience: 15

# 损失权重
w_nll: 1.0
w_path: 1.0
w_intensity: 0.5
w_physics: 0.3
w_temporal: 0.2
w_confidence: 0.5
```

### 7.2 模型文件格式

```python
checkpoint = {
    'model_state_dict': model.state_dict(),
    'optimizer_state_dict': optimizer.state_dict(),
    'train_losses': train_losses,
    'val_losses': val_losses,
    'best_val_loss': best_val_loss,
    'history': history,
    'feature_columns': FEATURE_COLUMNS,  # 14维特征列表
    'normalization_params': {
        'lat_min': -90.0,
        'lat_max': 90.0,
        'lon_min': -180.0,
        'lon_max': 180.0,
        'pressure_mean': 1000.0,
        'pressure_std': 50.0,
        'wind_mean': 20.0,
        'wind_std': 15.0,
    }
}
```
 """
    计算强度预测误差
    
    Returns:
        {
            "mean_pressure_error_hpa": 平均气压误差(hPa),
            "mean_wind_error_ms": 平均风速误差(m/s)
        }
    """
```

### 5.3 评估指标汇总

| 指标 | 目标值 | 说明 |
|------|--------|------|
| MAE (纬度) | < 0.5° | 平均绝对误差 |
| MAE (经度) | < 0.5° | 平均绝对误差 |
| 距离误差 | < 100km | Haversine距离 |
| 气压误差 | < 10hPa | 平均绝对误差 |
| 风速误差 | < 5m/s | 平均绝对误差 |

---

## 六、预测接口设计

### 6.1 标准预测接口

```python
class TyphoonPredictor:
    async def predict(
        self,
        historical_paths: List[PathData],
        forecast_hours: int = 48,
        typhoon_id: str = "",
        typhoon_name: Optional[str] = None
    ) -> PredictionResult:
        """
        执行台风路径预测
        
        Args:
            historical_paths: 历史路径数据列表(至少3个点，12小时跨度)
            forecast_hours: 预报时效(12/24/48/72/120)
            typhoon_id: 台风编号
            typhoon_name: 台风名称
            
        Returns:
            PredictionResult: 包含预测点列表、置信度等信息
        """
```

### 6.2 预测结果结构

```python
@dataclass
class PredictionResult:
    typhoon_id: str              # 台风编号
    typhoon_name: Optional[str]  # 台风名称
    forecast_hours: int          # 预报时效
    base_time: datetime          # 基准时间
    predictions: List[PredictedPoint]  # 预测点列表
    overall_confidence: float    # 整体置信度
    model_used: str             # 使用的模型
    is_fallback: bool = False   # 是否使用降级策略

@dataclass
class PredictedPoint:
    forecast_time: datetime      # 预报时间
    latitude: float             # 预测纬度
    longitude: float            # 预测经度
    center_pressure: Optional[float]  # 预测气压
    max_wind_speed: Optional[float]   # 预测风速
    confidence: float           # 该点置信度
```

### 6.3 降级策略

当深度学习模型不可用时，自动切换到线性外推降级策略：

```python
async def _fallback_prediction(self, historical_paths, forecast_hours, ...):
    """
    降级预测策略 (线性外推)
    
    计算最近5个点的平均移动趋势，进行线性外推
    """
    recent_paths = sorted(historical_paths, key=lambda x: x.timestamp)[-5:]
    
    # 计算平均移动趋势
    lat_diffs = np.diff([p.latitude for p in recent_paths])
    lon_diffs = np.diff([p.longitude for p in recent_paths])
    avg_lat_change = np.mean(lat_diffs)
    avg_lon_change = np.mean(lon_diffs)
    
    # 线性外推
    for i in range(1, num_points + 1):
        step_factor = (interval_hours * i) / 6.0
        pred_lat = last_point.latitude + avg_lat_change * step_factor
        pred_lon = last_point.longitude + avg_lon_change * step_factor
```

---

## 七、API端点

### 7.1 基础预测API

| 端点 | 方法 | 说明 |
|------|------|------|
| `/predictions/path` | POST | 路径预测 |
| `/predictions/intensity` | POST | 强度预测 |
| `/predictions/batch` | POST | 批量预测 |
| `/predictions/{typhoon_id}` | GET | 获取预测记录 |
| `/predictions/stats/{typhoon_id}` | GET | 预测统计信息 |

### 7.2 高级预测API

| 端点 | 方法 | 说明 |
|------|------|------|
| `/predictions/arbitrary-start` | POST | 任意起点预测 |
| `/predictions/rolling` | POST | 滚动预测 |
| `/predictions/virtual-observations` | POST | 虚拟观测点预测 |

### 7.3 请求示例

```bash
# 路径预测
curl -X POST "http://localhost:8000/api/v1/predictions/path" \
  -H "Content-Type: application/json" \
  -d '{
    "typhoon_id": "202601",
    "forecast_hours": 48
  }'

# 响应
{
  "typhoon_id": "202601",
  "predictions": [
    {
      "forecast_time": "2026-01-15T15:00:00",
      "latitude": 18.5,
      "longitude": 125.3,
      "center_pressure": 985.0,
      "max_wind_speed": 28.0,
      "confidence": 0.85
    }
  ],
  "overall_confidence": 0.82,
  "model_used": "TransformerLSTM"
}
```

---

## 八、性能优化策略

### 8.1 GPU优化

1. **混合精度训练**
```python
from torch.cuda.amp import autocast, GradScaler

scaler = GradScaler()

with autocast():
    pred_mean, pred_std, confidence = self.model(inputs)
    loss, metrics = self.criterion(pred_mean, pred_std, confidence, targets)

scaler.scale(loss).backward()
scaler.step(optimizer)
scaler.update()
```

2. **DataLoader优化**
```python
DataLoader(
    dataset,
    batch_size=64,
    num_workers=4,        # 多进程数据加载
    pin_memory=True,      # 固定内存，加速GPU传输
    persistent_workers=True  # 保持worker进程
)
```

3. **模型编译 (PyTorch 2.0+)**
```python
model = torch.compile(model, mode="reduce-overhead")
```

### 8.2 推理优化

1. **批处理推理**
```python
# 合并多个预测请求进行批处理
batch_inputs = torch.cat([input1, input2, ...], dim=0)
with torch.no_grad():
    predictions = model(batch_inputs)
```

2. **模型量化**
```python
# INT8量化，减少模型大小和推理时间
quantized_model = torch.quantization.quantize_dynamic(
    model, {nn.Linear}, dtype=torch.qint8
)
```

3. **缓存机制**
```python
# 缓存预处理结果
@functools.lru_cache(maxsize=128)
def get_preprocessed_data(typhoon_id):
    return preprocessor.prepare_prediction_input(paths)
```

### 8.3 内存优化

1. **梯度检查点**
```python
from torch.utils.checkpoint import checkpoint

# 在Transformer层使用梯度检查点
class TransformerBlock(nn.Module):
    def forward(self, x):
        return checkpoint(self._forward, x)
```

2. **及时释放显存**
```python
# 训练完成后释放缓存
torch.cuda.empty_cache()
```

---

## 九、部署与监控

### 9.1 模型保存格式

```python
checkpoint = {
    'model_state_dict': model.state_dict(),
    'optimizer_state_dict': optimizer.state_dict(),
    'train_losses': train_losses,
    'val_losses': val_losses,
    'best_val_loss': best_val_loss,
    'history': history,
    'feature_columns': FEATURE_COLUMNS,  # 14维特征列表
    'normalization_params': {
        'lat_min': -90.0,
        'lat_max': 90.0,
        'lon_min': -180.0,
        'lon_max': 180.0,
        'pressure_mean': 1000.0,
        'pressure_std': 50.0,
        'wind_mean': 20.0,
        'wind_std': 15.0,
    },
    'model_config': {
        'input_size': 14,
        'hidden_size': 256,
        'num_lstm_layers': 2,
        'num_transformer_layers': 2,
        'num_heads': 8,
        'output_size': 4,
        'prediction_steps': 8
    }
}
torch.save(checkpoint, 'best_model.pth')
```

### 9.2 训练监控

```python
# 使用TensorBoard记录训练过程
from torch.utils.tensorboard import SummaryWriter

writer = SummaryWriter(log_dir='runs/typhoon_prediction')

writer.add_scalar('Loss/train', train_loss, epoch)
writer.add_scalar('Loss/val', val_loss, epoch)
writer.add_scalar('Metrics/mae_lat', mae_lat, epoch)
writer.add_scalar('Metrics/mae_lon', mae_lon, epoch)
```

### 9.3 日志记录

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('training.log'),
        logging.StreamHandler()
    ]
)
```

---

## 十、常见问题与解决方案

### 10.1 特征维度不匹配

**问题**：模型期望14维输入，但实际提供10维

**解决方案**：
1. 统一使用 `FEATURE_COLUMNS` 常量定义特征顺序
2. 训练和预测使用相同的 `create_sequences` 方法
3. 在模型保存时记录特征列表，加载时验证

### 10.2 归一化参数不一致

**问题**：训练时使用全球范围归一化，预测时错误修改参数

**解决方案**：
1. 使用固定的 `NormalizationParams` 数据类
2. 将归一化参数保存到模型检查点
3. 预测时从检查点加载参数，不重新计算

### 10.3 GPU内存不足

**问题**：训练时CUDA Out of Memory

**解决方案**：
1. 减小batch_size
2. 使用梯度累积
3. 使用梯度检查点
4. 使用混合精度训练

### 10.4 模型过拟合

**问题**：训练集表现好，验证集表现差

**解决方案**：
1. 增加Dropout比例
2. 增加L2正则化
3. 使用早停策略
4. 数据增强

---

## 十一、文件清单

### 11.1 核心文件

| 文件路径 | 说明 | 行数 |
|---------|------|------|
| `app/services/prediction/data/preprocessor.py` | 数据预处理器 | 459 |
| `app/services/prediction/data/dataset.py` | PyTorch数据集 | 342 |
| `app/services/prediction/data/csv_loader.py` | CSV数据加载器 | 252 |
| `app/services/prediction/models/transformer_lstm_model.py` | 混合模型定义 | 138 |
| `app/services/prediction/predictor.py` | 预测器主类 | 549 |
| `app/services/prediction/utils/metrics.py` | 评估指标 | 191 |
| `training/train_model_v3.py` | 训练脚本 | 494 |
| `app/api/prediction.py` | API路由 | 988 |

### 11.2 配置文件

| 文件 | 说明 |
|------|------|
| `requirements.txt` | Python依赖 |
| `check_gpu.py` | GPU环境检查 |

---

## 十二、总结

本系统实现了基于PyTorch GPU加速的台风路径与强度预测功能，主要特点包括：

1. **纯CSV数据源**：仅使用项目内的历史台风数据，无需外部数据
2. **完整的预处理流程**：14维特征工程，统一归一化策略
3. **Transformer+LSTM混合架构**：结合时序建模和长程依赖捕捉
4. **GPU加速训练**：支持CUDA，充分利用GPU算力
5. **多维度评估**：路径误差、强度误差、置信度校准
6. **完善的API接口**：标准预测、批量预测、高级预测功能
7. **降级策略**：模型不可用时自动切换到线性外推

**关键设计原则**：
- 一致性：训练、验证、预测使用完全相同的预处理
- 可追溯：所有参数保存到模型检查点
- 模块化：数据、模型、推理层解耦
- 鲁棒性：完善的异常处理和降级机制
